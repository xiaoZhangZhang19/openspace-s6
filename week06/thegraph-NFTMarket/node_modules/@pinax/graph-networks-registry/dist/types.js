// To parse this data:
//
//   import { Convert, NetworksRegistryInner } from "./file";
//
//   const networksRegistryInner = Convert.toNetworksRegistryInner(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.
/**
 * Kind of API
 */
export var APIURLKind;
(function (APIURLKind) {
    APIURLKind["Blockscout"] = "blockscout";
    APIURLKind["Etherscan"] = "etherscan";
    APIURLKind["Ethplorer"] = "ethplorer";
    APIURLKind["Other"] = "other";
    APIURLKind["Subscan"] = "subscan";
})(APIURLKind || (APIURLKind = {}));
/**
 * Bytes encoding, e.g. hex, 0xhex, base58
 */
export var BytesEncoding;
(function (BytesEncoding) {
    BytesEncoding["Base58"] = "base58";
    BytesEncoding["Base64"] = "base64";
    BytesEncoding["Hex"] = "hex";
    BytesEncoding["Other"] = "other";
    BytesEncoding["The0Xhex"] = "0xhex";
})(BytesEncoding || (BytesEncoding = {}));
/**
 * [optional] Protocol name in graph-node, e.g. ethereum, near, arweave
 */
export var Protocol;
(function (Protocol) {
    Protocol["Arweave"] = "arweave";
    Protocol["Cosmos"] = "cosmos";
    Protocol["Ethereum"] = "ethereum";
    Protocol["Near"] = "near";
    Protocol["Other"] = "other";
    Protocol["Starknet"] = "starknet";
})(Protocol || (Protocol = {}));
/**
 * Whether the network is a mainnet/testnet/devnet
 */
export var NetworkType;
(function (NetworkType) {
    NetworkType["Devnet"] = "devnet";
    NetworkType["Mainnet"] = "mainnet";
    NetworkType["Testnet"] = "testnet";
})(NetworkType || (NetworkType = {}));
/**
 * Kind of relation
 */
export var RelationKind;
(function (RelationKind) {
    RelationKind["BeaconOf"] = "beaconOf";
    RelationKind["EvmOf"] = "evmOf";
    RelationKind["ForkedFrom"] = "forkedFrom";
    RelationKind["L2Of"] = "l2Of";
    RelationKind["Other"] = "other";
    RelationKind["ShardOf"] = "shardOf";
    RelationKind["TestnetOf"] = "testnetOf";
})(RelationKind || (RelationKind = {}));
// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    static toNetworksRegistryInner(json) {
        return cast(JSON.parse(json), r("NetworksRegistryInner"));
    }
    static networksRegistryInnerToJson(value) {
        return JSON.stringify(uncast(value, r("NetworksRegistryInner")), null, 2);
    }
}
function invalidValue(typ, val, key, parent = '') {
    const prettyTyp = prettyTypeName(typ);
    const parentText = parent ? ` on ${parent}` : '';
    const keyText = key ? ` for key "${key}"` : '';
    throw Error(`Invalid value${keyText}${parentText}. Expected ${prettyTyp} but got ${JSON.stringify(val)}`);
}
function prettyTypeName(typ) {
    if (Array.isArray(typ)) {
        if (typ.length === 2 && typ[0] === undefined) {
            return `an optional ${prettyTypeName(typ[1])}`;
        }
        else {
            return `one of [${typ.map(a => { return prettyTypeName(a); }).join(", ")}]`;
        }
    }
    else if (typeof typ === "object" && typ.literal !== undefined) {
        return typ.literal;
    }
    else {
        return typeof typ;
    }
}
function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}
function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}
function transform(val, typ, getProps, key = '', parent = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val)
            return val;
        return invalidValue(typ, val, key, parent);
    }
    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            }
            catch (_) { }
        }
        return invalidValue(typs, val, key, parent);
    }
    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1)
            return val;
        return invalidValue(cases.map(a => { return l(a); }), val, key, parent);
    }
    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val))
            return invalidValue(l("array"), val, key, parent);
        return val.map(el => transform(el, typ, getProps));
    }
    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(l("Date"), val, key, parent);
        }
        return d;
    }
    function transformObject(props, additional, val) {
        if (val === null || typeof val !== "object" || Array.isArray(val)) {
            return invalidValue(l(ref || "object"), val, key, parent);
        }
        const result = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, key, ref);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key, ref);
            }
        });
        return result;
    }
    if (typ === "any")
        return val;
    if (typ === null) {
        if (val === null)
            return val;
        return invalidValue(typ, val, key, parent);
    }
    if (typ === false)
        return invalidValue(typ, val, key, parent);
    let ref = undefined;
    while (typeof typ === "object" && typ.ref !== undefined) {
        ref = typ.ref;
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ))
        return transformEnum(typ, val);
    if (typeof typ === "object") {
        return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty("arrayItems") ? transformArray(typ.arrayItems, val)
                : typ.hasOwnProperty("props") ? transformObject(getProps(typ), typ.additional, val)
                    : invalidValue(typ, val, key, parent);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== "number")
        return transformDate(val);
    return transformPrimitive(typ, val);
}
function cast(val, typ) {
    return transform(val, typ, jsonToJSProps);
}
function uncast(val, typ) {
    return transform(val, typ, jsToJSONProps);
}
function l(typ) {
    return { literal: typ };
}
function a(typ) {
    return { arrayItems: typ };
}
function u(...typs) {
    return { unionMembers: typs };
}
function o(props, additional) {
    return { props, additional };
}
function m(additional) {
    return { props: [], additional };
}
function r(name) {
    return { ref: name };
}
const typeMap = {
    "NetworksRegistryInner": o([
        { json: "$schema", js: "$schema", typ: "" },
        { json: "description", js: "description", typ: "" },
        { json: "networks", js: "networks", typ: a(r("Network")) },
        { json: "title", js: "title", typ: "" },
        { json: "updatedAt", js: "updatedAt", typ: Date },
        { json: "version", js: "version", typ: "" },
    ], false),
    "Network": o([
        { json: "aliases", js: "aliases", typ: u(undefined, a("")) },
        { json: "apiUrls", js: "apiUrls", typ: u(undefined, a(r("APIURL"))) },
        { json: "caip2Id", js: "caip2Id", typ: "" },
        { json: "docsUrl", js: "docsUrl", typ: u(undefined, "") },
        { json: "explorerUrls", js: "explorerUrls", typ: u(undefined, a("")) },
        { json: "firehose", js: "firehose", typ: u(undefined, r("Firehose")) },
        { json: "fullName", js: "fullName", typ: "" },
        { json: "genesis", js: "genesis", typ: u(undefined, r("Genesis")) },
        { json: "graphNode", js: "graphNode", typ: u(undefined, r("GraphNode")) },
        { json: "icon", js: "icon", typ: u(undefined, r("Icon")) },
        { json: "id", js: "id", typ: "" },
        { json: "indexerDocsUrls", js: "indexerDocsUrls", typ: u(undefined, a(r("IndexerDocsURL"))) },
        { json: "issuanceRewards", js: "issuanceRewards", typ: true },
        { json: "nativeToken", js: "nativeToken", typ: u(undefined, "") },
        { json: "networkType", js: "networkType", typ: r("NetworkType") },
        { json: "relations", js: "relations", typ: u(undefined, a(r("Relation"))) },
        { json: "rpcUrls", js: "rpcUrls", typ: u(undefined, a("")) },
        { json: "secondName", js: "secondName", typ: u(undefined, "") },
        { json: "services", js: "services", typ: r("Services") },
        { json: "shortName", js: "shortName", typ: "" },
    ], false),
    "APIURL": o([
        { json: "kind", js: "kind", typ: r("APIURLKind") },
        { json: "url", js: "url", typ: "" },
    ], false),
    "Firehose": o([
        { json: "blockType", js: "blockType", typ: "" },
        { json: "bufUrl", js: "bufUrl", typ: "" },
        { json: "bytesEncoding", js: "bytesEncoding", typ: r("BytesEncoding") },
        { json: "evmExtendedModel", js: "evmExtendedModel", typ: u(undefined, true) },
    ], false),
    "Genesis": o([
        { json: "hash", js: "hash", typ: "" },
        { json: "height", js: "height", typ: 0 },
    ], false),
    "GraphNode": o([
        { json: "protocol", js: "protocol", typ: u(undefined, r("Protocol")) },
    ], false),
    "Icon": o([
        { json: "web3Icons", js: "web3Icons", typ: u(undefined, r("Web3Icons")) },
    ], false),
    "Web3Icons": o([
        { json: "name", js: "name", typ: "" },
        { json: "variants", js: "variants", typ: u(undefined, a("")) },
    ], false),
    "IndexerDocsURL": o([
        { json: "description", js: "description", typ: u(undefined, "") },
        { json: "url", js: "url", typ: "" },
    ], false),
    "Relation": o([
        { json: "kind", js: "kind", typ: r("RelationKind") },
        { json: "network", js: "network", typ: "" },
    ], false),
    "Services": o([
        { json: "firehose", js: "firehose", typ: u(undefined, a("")) },
        { json: "sps", js: "sps", typ: u(undefined, a("")) },
        { json: "subgraphs", js: "subgraphs", typ: u(undefined, a("")) },
        { json: "substreams", js: "substreams", typ: u(undefined, a("")) },
    ], false),
    "APIURLKind": [
        "blockscout",
        "etherscan",
        "ethplorer",
        "other",
        "subscan",
    ],
    "BytesEncoding": [
        "base58",
        "base64",
        "hex",
        "other",
        "0xhex",
    ],
    "Protocol": [
        "arweave",
        "cosmos",
        "ethereum",
        "near",
        "other",
        "starknet",
    ],
    "NetworkType": [
        "devnet",
        "mainnet",
        "testnet",
    ],
    "RelationKind": [
        "beaconOf",
        "evmOf",
        "forkedFrom",
        "l2Of",
        "other",
        "shardOf",
        "testnetOf",
    ],
};
